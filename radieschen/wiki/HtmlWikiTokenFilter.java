/*
 * Created on Mar 13, 2006
 *
 * The stream of token as generated by the wiki lexer is not complete: Opening list, tables
 * etc is implicit in the markup. This filter adds explicit tokens for these things into
 * the token stream in order to make the file life of the renderer easiser.
 * 
 * This version is for HTML. HTML has one serious problem: the paragraph cannot contain other 
 * elements as is usual for latex or docbook. This filter takes care of that.
 * 
 * Author: Mark.Koennecke@psi.ch
 * License: GPL
 */  
package radieschen.wiki;
import java.util.Stack;
import java.io.IOException;

public class HtmlWikiTokenFilter implements TokenProducer{

	private Stack tokenStack;
	private boolean paragraphOpen;
	private boolean tableOpen;
	private boolean defList; 
	private int ulListDepth;
	private int olListDepth;
	private TokenProducer input;
	
	public HtmlWikiTokenFilter(TokenProducer i ){
		input = i;
		tokenStack = new Stack();
		paragraphOpen = false;
		tableOpen = false;
		defList = false;
		ulListDepth = 0;
		olListDepth = 0;
	}

	/**
	 * main routine of  token handling
	 * @return the next token to process 
	 */
	public WikiToken nextToken()throws IOException{
		WikiToken tok;
		
		/*
		 * if there is something on the stack: serve it first
		 */
		if(!tokenStack.empty()){
			return (WikiToken)tokenStack.pop();
		}
		
		/*
		 * get a new token from input
		 */
		tok = input.nextToken();
		tokenStack.push(tok);
		/**
		 * check for eof
		 */
		if(tok == null){
			closeParagraph();
			closeStructureElements();
			return (WikiToken)tokenStack.pop();
		}
		
		/*
		 * the real logic
		 */
		switch(tok.getType()){
		case WikiToken.STARTCHAR:
			checkParOpen();
			checkTableOpen();
			checkDefListOpen();
			ulListDepth = handleListState(ulListDepth,0,WikiToken.ULLIST,WikiToken.ULITEMCLOSE,
					WikiToken.ULLISTOPEN, WikiToken.ULLISTCLOSE);
			olListDepth = handleListState(olListDepth,0,WikiToken.OLLIST,WikiToken.OLITEMCLOSE,
					WikiToken.OLLISTOPEN, WikiToken.OLLISTCLOSE);
			break;
		case WikiToken.PAREND:
			if(!paragraphOpen){
				tokenStack.pop();
				tokenStack.push(new WikiToken(WikiToken.IGNORE));
			} else {
				paragraphOpen = false;
			}
			closeStructureElements();
			break;
		case WikiToken.RULE:
		case WikiToken.STRONGRULE:
		case WikiToken.STARTHEADER:
			closeStructureElements();
			break;
		case WikiToken.TABLEROW:
			if(!tableOpen){
				tokenStack.push(new WikiToken(WikiToken.TABLEOPEN));
				closeStructureElements();
				tableOpen = true;
			}
			break;
		case WikiToken.OLLIST:
			olListDepth = handleListState(olListDepth,countListDepth(tok.getText()),
					WikiToken.OLLIST,WikiToken.OLITEMCLOSE,WikiToken.OLLISTOPEN, WikiToken.OLLISTCLOSE);
			closeParagraph();
			checkTableOpen();
 			checkDefListOpen();
			ulListDepth = handleListState(ulListDepth,0,WikiToken.ULLIST,WikiToken.ULITEMCLOSE,
					WikiToken.ULLISTOPEN, WikiToken.ULLISTCLOSE);
			break;
		case WikiToken.ULLIST:
			ulListDepth = handleListState(ulListDepth,countListDepth(tok.getText()),
					WikiToken.ULLIST,WikiToken.ULITEMCLOSE,WikiToken.ULLISTOPEN, WikiToken.ULLISTCLOSE);
			closeParagraph();
			checkTableOpen();
			checkDefListOpen();
			olListDepth = handleListState(olListDepth,0,WikiToken.OLLIST,WikiToken.OLITEMCLOSE,
					WikiToken.OLLISTOPEN, WikiToken.OLLISTCLOSE);
			break;
		case WikiToken.DEFLIST:
			if(defList){
				tokenStack.push(new WikiToken(WikiToken.DEFDATACLOSE));
			} else {
				tokenStack.push(new WikiToken(WikiToken.DEFLISTOPEN));
				closeStructureElements();
				defList = true;
			}
			break;
		}
		return (WikiToken)tokenStack.pop();
	}
	/**
	 * close all structural elements which may still be open.
	 */
	private void closeStructureElements(){
		checkTableOpen();
		checkDefListOpen();
		ulListDepth = handleListState(ulListDepth,0,WikiToken.ULLIST,WikiToken.ULITEMCLOSE,
				WikiToken.ULLISTOPEN, WikiToken.ULLISTCLOSE);
		olListDepth = handleListState(olListDepth,0,WikiToken.OLLIST,WikiToken.OLITEMCLOSE,
				WikiToken.OLLISTOPEN, WikiToken.OLLISTCLOSE);
		closeParagraph();
	}
	/**
	 * close a potentially open paragraph
	 */
	private void closeParagraph(){
		if(paragraphOpen){
			tokenStack.push(new WikiToken(WikiToken.PAREND));
			paragraphOpen = false;
		}
	}
	/**
	 * count the statcking depth of the list
	 * @param text The list item text
	 * @return The stacking depth
	 */
	private int countListDepth(String text){
		return text.trim().length();
	}
	/**
	 * handle list state management
	 * @param current current list depth
	 * @param target target list depth
	 * @param itemClose token for closing item
	 * @param listStart token for starting list
	 * @param listClose token for closing list
	 * @return new current list depth
	 */
	private int handleListState(int current, int target, int itemOpen, int itemClose, 
			int listStart, int listClose){
	int i;
	
	if(target == current && current > 0){
		tokenStack.push(new WikiToken(itemClose));
	}  else  if(target > current){
		for(i = current; i < target; i++){
			tokenStack.push(new WikiToken(listStart));
		}
	} else if(target < current){
		for(i = current; i > target; i-- ){
			if(current > 1){
				tokenStack.push(new WikiToken(itemClose));
			}
			tokenStack.push(new WikiToken(listClose));
			tokenStack.push(new WikiToken(itemClose));
		}
	}
	return target;
}
	/**
	 * checks if a a paragraph is open. If not pushes the necessary token
	 */
	private void checkParOpen(){
		if(!paragraphOpen){
			paragraphOpen = true;
			tokenStack.push(new WikiToken(WikiToken.PAROPEN));
		}
	}
	/**
	 * checks if a a definition list  is open. If not pushes the necessary tokens
	 */
	private void checkDefListOpen(){
		if(defList){
			defList = false;
			tokenStack.push(new WikiToken(WikiToken.DEFLISTCLOSE));
			tokenStack.push(new WikiToken(WikiToken.DEFDATACLOSE));
		}
	}
	/**
	 * checks for an open table
	 */
	private void checkTableOpen(){
		if(tableOpen){
			tableOpen = false;
			tokenStack.push(new WikiToken(WikiToken.TABLECLOSE));
		}
	}
}
